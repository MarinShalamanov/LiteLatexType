// Generated by CoffeeScript 1.10.0
(function() {
  var Atom, BinaryOperator, Block, Term, UnaryOperator, extractBrackets, handleBinaryOperator, isLetter, isNumber, proccess, tokenize,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  window.square = function(x) {
    x = 5;
    return x * x;
  };

  Term = (function() {
    function Term() {}

    Term.prototype.toString = function() {};

    return Term;

  })();

  Atom = (function(superClass) {
    extend(Atom, superClass);

    function Atom(val) {
      this.val = val;
      this.toString = bind(this.toString, this);
    }

    Atom.prototype.toString = function() {
      return "" + this.val;
    };

    return Atom;

  })(Term);

  UnaryOperator = (function(superClass) {
    extend(UnaryOperator, superClass);

    function UnaryOperator(operator1, val) {
      this.operator = operator1;
      this.val = val;
      this.toString = bind(this.toString, this);
    }

    UnaryOperator.prototype.toString = function() {
      return "\\" + this.operator + "{" + this.val.toString + "}";
    };

    return UnaryOperator;

  })(Term);

  BinaryOperator = (function(superClass) {
    extend(BinaryOperator, superClass);

    function BinaryOperator(operator1, val1, val2) {
      this.operator = operator1;
      this.val1 = val1;
      this.val2 = val2;
      this.toString = bind(this.toString, this);
    }

    BinaryOperator.prototype.toString = function() {
      var ref, ref1, val1Str, val2Str;
      val1Str = this.val1.toString();
      val2Str = this.val2.toString();
      if ((ref = this.operator) === '^' || ref === '_') {
        if (this.val2 instanceof Block) {
          val2Str = this.val2.toStringWithoutBrackets();
        }
        return "" + val1Str + this.operator + "{" + val2Str + "}";
      }
      if ((ref1 = this.operator) === '+' || ref1 === '-' || ref1 === '*') {
        return "" + val1Str + this.operator + val2Str;
      }
      return "\\" + (this.operator.toString()) + "{" + val1Str + "}{" + val2Str + "}";
    };

    return BinaryOperator;

  })(Term);

  Block = (function(superClass) {
    extend(Block, superClass);

    function Block(values) {
      this.values = values;
      this.toStringWithoutBrackets = bind(this.toStringWithoutBrackets, this);
      this.toString = bind(this.toString, this);
    }

    Block.prototype.toString = function() {
      if (this.values.length === 1) {
        return this.values[0].toString();
      }
      return "(" + this.values.join(" ") + ")";
    };

    Block.prototype.toStringWithoutBrackets = function() {
      return this.values.join(" ");
    };

    return Block;

  })(Term);

  isLetter = function(l) {
    return /[a-z0-9]/i.test(l);
  };

  isNumber = function(l) {
    return /[0-9]/i.test(l);
  };

  tokenize = function(str) {
    var i, j, tokens;
    tokens = [];
    i = 0;
    while (i < str.length) {
      if (str.charAt(i) === ' ') {

      } else if (isNumber(str.charAt(i))) {
        j = i + 1;
        while (isNumber(str.charAt(j))) {
          j++;
        }
        tokens.push(str.substring(i, j));
        i = j - 1;
      } else if (str.charAt(i) === '\\') {
        j = i + 1;
        while (isLetter(str.charAt(j))) {
          j++;
        }
        tokens.push(str.substring(i, j));
        i = j - 1;
      } else {
        tokens.push(str.charAt(i));
      }
      i++;
    }
    return tokens;
  };

  extractBrackets = function(tokens) {
    var found, i, it, j, k, len, len1, m, newTokens, numOpenBrackets, ref, ref1;
    while (true) {
      newTokens = [];
      i = 0;
      found = false;
      while (i < tokens.length) {
        if (tokens[i] === '(') {
          found = true;
          break;
        }
        i++;
      }
      if (!found) {
        return tokens;
      }
      ref = tokens.slice(0, i);
      for (k = 0, len = ref.length; k < len; k++) {
        it = ref[k];
        newTokens.push(it);
      }
      numOpenBrackets = 1;
      j = i + 1;
      while (j < tokens.length) {
        if (tokens[j] === '(') {
          numOpenBrackets++;
        } else if (tokens[j] === ')') {
          numOpenBrackets--;
          if (numOpenBrackets === 0) {
            break;
          }
        }
        j++;
      }
      newTokens.push(new Block(proccess(tokens.slice(i + 1, j))));
      j++;
      if (j < tokens.length) {
        ref1 = tokens.slice(j);
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          it = ref1[m];
          newTokens.push(it);
        }
      }
      tokens = newTokens;
    }
  };

  handleBinaryOperator = function(tokens, operator, operatorParsed) {
    var denom, foundFraction, frac, i, it, k, len, len1, m, n, newTokens, nom, ref, ref1, ref2;
    while (true) {
      foundFraction = false;
      newTokens = [];
      i = 0;
      for (i = k = 1, ref = tokens.length - 2; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
        if (tokens[i] === operator) {
          foundFraction = true;
          break;
        }
      }
      if (!foundFraction) {
        return tokens;
      }
      ref1 = tokens.slice(0, i - 1);
      for (m = 0, len = ref1.length; m < len; m++) {
        it = ref1[m];
        newTokens.push(it);
      }
      nom = tokens[i - 1];
      denom = tokens[i + 1];
      frac = new BinaryOperator(operatorParsed, nom, denom);
      newTokens.push(frac);
      i = i + 2;
      if (i < tokens.length) {
        ref2 = tokens.slice(i);
        for (n = 0, len1 = ref2.length; n < len1; n++) {
          it = ref2[n];
          newTokens.push(it);
        }
      }
      tokens = newTokens;
    }
  };

  proccess = function(tokens) {
    tokens = extractBrackets(tokens);
    tokens = handleBinaryOperator(tokens, "^", "^");
    tokens = handleBinaryOperator(tokens, "_", "_");
    tokens = handleBinaryOperator(tokens, "/", "frac");
    return tokens;
  };

  window.parseToLatex = function(str) {
    var exp, outstr, tokens;
    str = str.replace(/\r\n|\r|\n/g, "\\newline ");
    str = str.replace(/cos/g, "\\cos ");
    str = str.replace(/sin/g, "\\sin ");
    str = str.replace(/sq/g, "\\sqrt ");
    str = str.replace(/\\i/g, "\\int ");
    str = str.replace(/ln/g, "\\ln ");
    str = str.replace(/log/g, "\\log ");
    tokens = tokenize(str);
    tokens = proccess(tokens);
    exp = new Block(tokens);
    return outstr = exp.toStringWithoutBrackets();
  };

}).call(this);
